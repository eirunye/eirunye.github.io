<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介1.学习本篇博文，我们知道在什么场景下使用策略模式。2.策略模式的优缺点。3.策略模式的思想。 场景 某公司需要每个周五每名员工都要提交周报，在该公司可以提交周报的行为或者“算法”有：邮箱提交、SVN、Git后两种一般是开发部门使用的(刚开始还没有Git提交方式)。 那么在该场景中我们是如何设计业务逻辑呢？ 你可能这么想，我用继承的方式多好，在一个超类中都定义有邮箱提交，SVN提交，然后具体角色去继承，然后分别实现这些方法，在进行调用。 但是你是不是忽略了一个问题，一个人事部门的前台小姐姐并不会SVN提交方式，你确实给她也拥有这样的方式了，这不是明显的设计漏洞吗？ 而且当你使用这样的方式的时候，如果开发部门经理，又提出新的想法添加了Git提交方式，那么你是不是需要修改了很多代码了呢？牵一发而动全身啊 子类的代码重复到你崩溃了，而且很多部门使用的提交方式不同，我们并不需要知道其他部门的提交方式等等。 所以继承很难解决我们现在的问题了。 那么我们应该怎么设计呢？ 答案就是下文 分析什么是策略模式？ 策略模式是：定义了算法族，分别封装起来，让其相互替换，相互独立，为达到算法动态修改的角色提供了独立。 为什么需要策略模式？ 1.从定义可以看出策略模式是定义了行为“算法”族，将其封装起来，给用户使用的，如果算法改变，那么只需添加或者修改算法方式便能解决问题了，而无需修改其他原有的行为“算法”，因为他们是相互独立的。 2.内部维护一个Strategy的实例。 3.负责动态设置运行时具体角色的实现算法。 4.负责跟Strategy之间的交互和数据传递。 进入代码分析具体实现步骤： 1.定义一个行为“算法”，该行为“算法”是一个抽象类或者是接口2.各种独立的行为去实现该行为“算法”接口3.定义一个角色，是一个抽象超类或者接口4.超类角色里面有一个封装的行为或者是“算法”的属性5.定义一个方法进行委托该行为或者“算法”6.具体的角色继承超类角色，并实现抽象方法 具体代码SubmissionBehavior 接口12345678910/** * Author Eirunye * Created by on 2018/8/31. * Describe 定义了一个提交的行为称为一簇&quot;算法&quot; * 这可以是一个抽象类火或者是一个接口 */public interface SubmissionBehavior &#123; void commit();&#125; MailCommitBehavior.class 1234567891011/** * Author Eirunye * Created by on 2018/8/31. * Describe 邮箱提交行为 */public class MailCommitBehavior implements SubmissionBehavior&#123; @Override public void commit() &#123; System.out.println(&quot;邮箱提交周报行为&quot;); &#125;&#125; Character.class 抽象类1234567891011121314151617181920212223/** * Author Eirunye * Created by on 2018/8/31. * Describe 定义一个抽象超类角色 * 或者这里也可以是接口 */public abstract class Character &#123; //一个角色有一个这样的行为 public SubmissionBehavior submissionBehavior; public abstract void display(); //完成提交行为 委托 public void completeCommit()&#123; submissionBehavior.commit(); &#125; //动态设置行为 public void setSubmissionBehavior(SubmissionBehavior submissionBehavior) &#123; this.submissionBehavior = submissionBehavior; &#125;&#125; Coder.class 具体的角色12345678910111213141516/** * Author Eirunye * Created by on 2018/8/31. * Describe 开发员 */public class Coder extends Character&#123; public Coder() &#123; submissionBehavior = new SVNCommitBehavior(); &#125; @Override public void display() &#123; System.out.println(&quot;刚开始使用的周报提交方式是SVN&quot;); &#125;&#125; 测试Test.class1234567891011121314151617181920212223/** * Author Eirunye * Created by on 2018/8/31. * Describe 测试 */public class Test &#123; public static void main(String[] args) &#123; //创建一个码农提交方式 Character character = new Coder(); character.completeCommit(); //创建一个前台小姐姐提交方式 Character character1 = new ReceptionSister(); character1.completeCommit(); //某天开发部们经理说了以后开发部要统一使用Git方式提交周报了， //那么如下看看发生什么情况 Character character2 = new Coder(); character2.setSubmissionBehavior(new GitCommitBehavior());//动态设置提交方式 character2.completeCommit(); &#125;&#125; 输出结果：123456C:\Java\jdk1.8.0_161\bin\...SVN提交行为邮箱提交周报行为新增的Git提交周报行为Process finished with exit code 0 下载策略模式案例代码 总结我们学习了策略模式，在生活中是经常运用到的，本例只是一个场景。我们在设计开发的时候一定要“多用组合，少用继承”。针对接口变成，而不针对实现编程。 优点 1.策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。通过使用继承抽象超类可以把公共的代码转移到抽象超类父类里面，从而避免重复的代码。2.通过实现接口的方式定义具体的行为“算法”，从而减少子类继承父类相互混淆的行为。3.使用策略模式可以避免使用多重条件转移语句，动态的改变行为，而各个具体角色行为“算法”相互独立。 缺点 1.客户端必须知道所有的具体角色，并决定使用哪个算法族，这样在设计开始时是需要花费时间是封装“算法”族的，策略模式只适用于客户端知道所有的算法或行为的情况。2.策略模式造成很多具体的角色，每个具体角色就得创建一个新的类，这样类无法相互联系，所以无法共享。]]></content>
      <categories>
        <category>设计模式</category>
        <category>策略模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F09%2F01%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介1.学习本篇博文，我们知道在什么场景下使用观察者模式。2.观察者模式的优缺点。3.观察者模式给我们在今后开发中什么思想。 场景某家科技公司目前在开发一个项目，设计小组需要上报项目的进度给部门经理，主要有两个模块更新原有的业务模块进度和添加新业务的模块完成进度。那么部门经理需要什么途径能最快的得到进度的信息呢？或者可能是项目总监也想参与，去获取到最新的进展情况呢？我们改如何去考虑这个业务呢？ 很多时候我们就会想到继承去解决这一情况，毕竟OO编写思想时刻影响这一我们，但是如果某天项目经理出差了，他不想看项目进度了，那我们又改怎么办呢？ 我们能不能就是设计一个业务，让能想知道该进度的人，不管什么时候，只要有开发者上报进度的时候就一下他就得到进度的信息，而他无需去关系这个过程。 你是否能想到合适的解决方案呢？ 答案就在下文中，你准备好了吗？ 问题什么是观察者模式？观察者模式定义一系列对象之间的一对多关系，当一个对象改变、更新状态时，依赖它的都会收到通知改变或者更新。 为什么需要观察者模式从定义中我们可以知道观察者模式当对象改变时，其他依赖的对象都会收到改变信息的状态。 从本例分析项目经理想知道进度情况，他只需要绑定进度，他就可以知道进度信息了，而无需关心如何操作，如果再增加一个想知道进度信息老板呢？也很容易，也让老板绑定进度信息数据就好了，不想知道的时候就解除绑定，就不在获取进度信息了。 所以在本案例场景中，观察者是我们这个场景非常合适的设计。 如何实现观察者模式？自定义观察者模式实现如下我们先来看一下这个UML类图进行分析 1.构造一个主题Subject或者是一个被观察者Observeable，这是一个接口或者是抽象类 12345678 public interface Subject &#123; //注册观察者 void registerObserver(Observer observe); //解除绑定观察者 void unRegisterObserver(Observer observe); //更新数据 void notifyObservers();&#125; 2.构建一个被观察者实现该主题接口如本例的 DevelopmentProgressData.class，这里是进度信息数据 在registerObserver(Observer o);//方法中将观察者添加到注册列表中 在unRegisterObserve(Observer o);//删除观察者 1234567891011121314151617181920212223242526public class DevelopmentProgressData implements Subject &#123; @Override public void registerObserver(Observer observer) &#123; //将观察者添加到列表中 arrayObserve.add(observer); &#125; @Override public void unRegisterObserver(Observer observer) &#123; int i = arrayObserve.indexOf(observer); if (i &gt;= 0) &#123; //将观察者从列表中解除 arrayObserve.remove(i); &#125; &#125; //通知所以观察者数据更新了 @Override public void notifyObservers() &#123; for (int i = 0; i &lt; arrayObserve.size(); i++) &#123; Observer o = (Observer) arrayObserve.get(i); o.update(completeProgress, updateProgress); &#125; &#125;&#125; 3.构建一个观察者接口Observer 1234public interface Observer &#123; //更新数据 void update(int completeProgress, int updateProgress);&#125; 4.可构建一个展示数据的接口（可忽略） 有展示数据的方法，观察者要实现这个方法 查看本例的 DisplaySchedule 123public interface DisplaySchedule &#123; void display();&#125; 5.定义观察者(模拟该类就是产品经理观察者)，需实现接口Observes、DisplaySchedule(可忽略)， 、将主题Subject设置为观察者的属性，并将其作为观察者的构造函数如 ProductManagerObserver.class调用 developmentProgressSubject.registerObserver(this);将观察者注册到观察列表中12345678910111213141516171819202122232425public class ProductManagerObserver implements Observer, DisplaySchedule &#123; private int completeProgress;//完成进度 private int updateProgress;//更新进度 //将主题当成观察者的属性 private Subject developmentProgressSubject; public ProductManagerObserver(Subject developmentProgressSubject) &#123; this.developmentProgressSubject = developmentProgressSubject; //注册该观察者 developmentProgressSubject.registerObserver(this); &#125; @Override public void display() &#123; System.out.println(&quot;产品经理管理者显示当前数据 完成进度为: &quot; + completeProgress + &quot;更新修改进度为:&quot; + updateProgress); &#125; @Override public void update(int completeProgress, int updateProgress) &#123; this.completeProgress = completeProgress; this.updateProgress = updateProgress; display(); &#125;&#125; 6.测试 RunTest.class1234567891011121314public class RunTest &#123; public static void main(String[] args) &#123; DevelopmentProgressData developmentProgressData = new DevelopmentProgressData(); ProductManagerObserver productManagerObserver = new ProductManagerObserver(developmentProgressData); ProjectManagerObserver projectManagerObserver = new ProjectManagerObserver(developmentProgressData); developmentProgressData.setCurrentData(34, 45); //当项目经理出差了，不观察项目进度了就取消订阅了 developmentProgressData.unRegisterObserver(projectManagerObserver); //当前只有产品经理获取到数据 developmentProgressData.setCurrentData(46, 90); &#125;&#125; 输出结果：123456C:\Java\jdk1.8.0_161\bin\...产品经理管理者显示当前数据 完成进度为: 34更新修改进度为:45项目管理真显示当前数据完成进度为: 34更新修改进度为:45产品经理管理者显示当前数据 完成进度为: 46更新修改进度为:90Process finished with exit code 0 根据java.util.observerable包下的Observerable.class实现观察者模式功能实现如下 1.首先观察者需要实现java.util.Observer,然后将其被观察者=&gt;java.util.Observaerable作为其观察者的构造函数 、通过observeable.addObserver(this)添加观察者 123456789101112131415161718192021222324252627 public class BossMngObserver implements Observer, DisplayIllustrate &#123; private Observable observable; private int valuableProductNum; //库存有贵重产品 private int normalProductNum; //普通产品 public BossMngObserver(Observable observable) &#123; this.observable = observable; observable.addObserver(this); &#125; @Override public void disPlay() &#123; System.out.println(&quot;总经理观察数据改变:贵重产品数量: &quot; + valuableProductNum + &quot;普通产品数量： &quot; + normalProductNum); &#125; //&lt;2&gt;、实现 Observer更新数据方法 //看本例的包下的observe的三个类 @Override public void update(Observable o, Object arg) &#123; if (o instanceof InventoryData) &#123; InventoryData inventoryData = (InventoryData) o; this.valuableProductNum = inventoryData.getValuableProductNum(); this.normalProductNum = inventoryData.getNormalProductNum(); disPlay(); &#125; &#125;&#125; 2.被观察者需要继承java.util.Observerable, 、然后先调用setChanged()方法 、在进行调用notifyObserves()更新数据 1234567891011121314151617 public class InventoryData extends Observable &#123; private int valuableProductNum; //库存有贵重产品 private int normalProductNum; //普通产品 public void setCurrentData(int valuableProductNum, int normalProductNum) &#123; this.valuableProductNum = valuableProductNum; this.normalProductNum = normalProductNum; statusChange(); &#125; private void statusChange() &#123; //先调用 setChanged(); setChanged(); notifyObservers(); &#125;&#125; 3.测试 Test.class1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; InventoryData inventoryData = new InventoryData(); ValuableInfoMngObserver io = new ValuableInfoMngObserver(inventoryData); //io.deleteObserve(); inventoryData.setCurrentData(20, 30); NormalInfoMngObserver no = new NormalInfoMngObserver(inventoryData); //no.deleteObserver(); inventoryData.setCurrentData(15, 27); BossMngObserver bossMngObserver = new BossMngObserver(inventoryData); inventoryData.setCurrentData(10, 50); &#125;&#125; 下载观察者模式案例代码 总结观察者模式的让我们知道了在设计开发的时候一定要“多用组合，少用继承”。 我们设计开发是应该是针对接口变成，而不针对实现编程。 在java.util.*下的Observer和Observable可以实现观察者，但是Observable是一个类，这样我们是不违背了“多用组合少用继承”的OO编程思想，是的没错在java.util.Observable类违背了该规则。]]></content>
      <categories>
        <category>设计模式</category>
        <category>观察者模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目如何搭建(四)]]></title>
    <url>%2F2018%2F08%2F22%2FSpring-Boot-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[简介Spring Boot项目的搭建，常用实例分析在项目开发中我们一般情况下提供给APP或者网站应用的接口一般的请求方式是GET、POST、PUT等等，那么接下来我们将通过一个简单的案例来进行分析，带领大家进入Spring Boot项目的开发，创建(层级分明，思路请析)、编码，主要是 搭建项目 等。 项目结构创建项目目录如下,包层级分明一般如下图所示: 在src目录下的main/java里面的创建的包级目录,进行分析如下:1234567891011/============================|-- controller：主要是控制器，通过注解@RestController，Spring4之后新加的注解，原来返回json数据格式，通@RequestMapping，设置访问URI。|-- enums: 主要是封装返回码的提示。|-- exception: 主要是封装异常打印输出。|-- handle: 捕捉异常处理|-- model：实体类|-- repository：Jpa使用封装|-- service：逻辑处理封装，返回数据给Controller类|-- utils：封装一些工具类|-- 其他：在开发中还有一些需要创建其他包，根据自己需求。\============================ 主要代码分析这里主要是写一个简单的事例进行参考包层级之间的调用。 代码注解如下: EirunyeController.class1234567891011121314151617@RestController@RequestMapping(&quot;/Eirunye&quot;) //设置请求的父级标签URIpublic class EirunyeController &#123; @Autowired //注:Autowired是按类型进行装配，可获取它所装配类的属性 EirunyeService eirunyeService; /** * 访问返回数据 * @return Result&lt;EiBean&gt; * @throws Exception 出现异常处理 */ @GetMapping(value = &quot;/bean&quot;) public Result&lt;EiBean&gt; getEiBeanData() throws Exception &#123; return eirunyeService.getEiBeanData(); &#125;&#125; EirunyeService.class@Service 用于标注业务层组件：将当前类注册为Spring的Bean 123456789101112131415@Service // 用于标注业务层组件：将当前类注册为Spring的Beanpublic class EirunyeService &#123; /** * @return Result&lt;EiBean&gt; * @throws EirunyeException 异常处理 */ public Result&lt;EiBean&gt; getEiBeanData() throws EirunyeException&#123; EiBean eiBean = new EiBean(); eiBean.setName(&quot;Eirunye&quot;); eiBean.setAge(19); eiBean.setHobby(&quot;Java Spring Boot&quot;); return ResultUtil.globalInfo(ResultEnum.SUCCESS,eiBean); &#125;&#125; EiBean.class 123456789public class EiBean &#123; private String name; private int age; private String hobby;//get/set...&#125; 测试在接下来会有一篇博文会详细讲解在开发中我们如何进行测试(#)，这里只进行一些简单测试 在这里我们只需要进行一下访问结果，如下: Postman请求如下: IDEA请求如下: 下载本例搭建项目demo 总结 1.学习本篇，我们知道如何搭建一个好的项目工程,常用的功能架构 2.这是创建Spring Boot 项目所需要分层的，希望对大家有所帮助 3.大家有什么疑问可以留言哦！！！]]></content>
      <categories>
        <category>后台</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 配置文件设置(三)]]></title>
    <url>%2F2018%2F08%2F20%2FSpring-Boot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[简介上篇我们做了一些简单的运行文件的配置，本篇带领大家来认识常用的一些配置，当然了关于Spring Boot 这些配置太多太多了，如果想了解更多的话直接上官网参考一下，了解相关案例如本篇的配置。 application.properties配置官方指南参考。 Spring Boot有以下方式配置application.properties配置在 IntelliJ IDEA 开发工具中创建项目的时候，默认的配置文件是application.properties，接下来我们就学习一下然后配置一些我们在开发中经常用到的配置项，进入带领我们揭开Spring Boot 项目的神秘的面纱。在下面的文档中我会在每个配置中进行注解，这样能更好的了解，当然官方文档有我们所需的全部配置，大家如果项目开发中有需求那么可以进入application.properties配置官方指南参考。 英: Appendix A. Common application properties 1234567Various properties can be specified inside your application.properties file, inside your application.yml file, or as command line switches.This appendix provides a list of common Spring Boot properties and references to the underlying classes that consume them.[Note]Property contributions can come from additional jar files on your classpath, so you should not consider this an exhaustive list.Also, you can define your own properties.[Warning]This sample file is meant as a guide only. Do not copy and paste the entire content into your application. Rather, pick only the properties that you need. 译: 官方指南者三段话概况了今天我们要讲得内容：12345可以在application.properties文件中，application.yml文件中或命令行开关中指定各种属性。 本附录提供了常用Spring Boot属性的列表以及对使用它们的基础类的引用。[注意]属性贡献可以来自类路径上的其他jar文件，因此您不应将此视为详尽的列表。 此外，您可以定义自己的属性。[警告]此示例文件仅供参考。 不要将整个内容复制并粘贴到您的应用程序中。 相反，只选择您需要的属性。 所以我们在添加某些配置属性的时候，一定要根据自己的需要来添加，不然有时出错了，不知道哪里找问题。 常用的application.properties配置一般情况下在src目录下的/main/resource文件夹中新建application.properties文件，目录结构如下：1234|--src |--main |--resources |--application.properties 我们接下来编写一些常用的属性配置，大家在开发中需要到哪些就直接去查看一下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#启用调试日志。debug=false#启用跟踪日志。trace=false#--------------------------------------# LOGGING 日记#--------------------------------------# 日志配置文件的位置。 例如，Logback的classpath:logback.xmllogging.config=classpath:logback.xml# 日志文件名（例如，`myapp.log`）。名称可以是精确位置或相对于当前目录。logging.file=property.log# 最大日志文件大小。 仅支持默认的logback设置logging.file.max-size=10MB# 日志文件的位置。 例如，`/ var / log`。logging.path=/var/log#---------------------------------# AOP#---------------------------------# 使用AOP 切面编程spring.aop.auto=true#是否要创建基于子类的（CGLIB）代理（true），而不是基于标准Java接口的代理（false）spring.aop.proxy-target-class=true#--------------------------------# Email#--------------------------------# 编码格式spring.mail.default-encoding=UTF-8# SMTP服务器主机spring.mail.host=smtp.property.com#SMTP服务器端口spring.mail.port=7800# 登录SMTP用户名spring.mail.username=property# 登录SMTP密码spring.mail.password=123456#--------------------------------# WEB 属性配置#--------------------------------# 服务器应绑定的网络地址server.address=127.0.0.1# 是否启用了响应压缩server.compression.enabled=false# 连接器在关闭连接之前等待另一个HTTP请求的时间。 未设置时，将使用连接器的特定于容器的默认值。 使用值-1表示没有（即无限）超时server.connection-timeout=2000# 错误控制器的路径server.error.path=/error# 是否启用HTTP / 2支持，如果当前环境支持它。server.http2.enabled=false# 服务器端口默认为:8080server.port=8084# SP servlet的类名。server.servlet.jsp.class-name=org.apache.jasper.servlet.JspServlet# 主调度程序servlet的路径。server.servlet.path=/home# 会话cookie名称server.servlet.session.cookie.name=propertydemo#------------------------------# HTTP encoding#------------------------------# HTTP请求和响应的字符集。 如果未明确设置，则添加到“Content-Type”标头。spring.http.encoding.charset=UTF-8# 是否启用http编码支持。spring.http.encoding.enabled=true#--------------------# MULTIPART (MultipartProperties)#--------------------# 是否启用分段上传支持spring.servlet.multipart.enabled=true# 上传文件的中间位置spring.servlet.multipart.location=/log# 最大文件的大小spring.servlet.multipart.max-file-size=1MB# 最大请求大小spring.servlet.multipart.max-request-size=10MB# 是否在文件或参数访问时懒惰地解析多部分请求。spring.servlet.multipart.resolve-lazily=false#--------------------------------------------# SPRING SESSION JDBC (JdbcSessionProperties)#--------------------------------------------# cron表达式用于过期的会话清理作业spring.session.jdbc.cleanup-cron=0 * * * * *# 数据库模式初始化模式spring.session.jdbc.initialize-schema=embedded# 用于初始化数据库模式的SQL文件的路径spring.session.jdbc.schema=classpath:org/springframework/session/jdbc/schema-@@platform@@.sql# 用于存储会话的数据库表的名称spring.session.jdbc.table-name=SPRING_SESSION#----------------------------------# MONGODB 数据库配置#----------------------------------# 数据库名称spring.data.mongodb.database=demo# host 配置spring.data.mongodb.host=127.0.0.1# 登录用户名spring.data.mongodb.username=property# 登录密码spring.data.mongodb.password=123456# 端口号，自己根据安装的mongodb端口配置spring.data.mongodb.port=9008# 要启用的Mongo存储库的类型spring.data.mongodb.repositories.type=auto# 连接数据urispring.data.mongodb.uri=mongodb://localhost/test#---------------------------------------# DATASOURCE 数据库配置#---------------------------------------# MySql jdbc Driverspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 连接数据库# demo表示的是你创建的数据库;spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useSSL=false&amp;requireSSL=false&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC# 数据库用户名spring.datasource.username=root# 数据库密码spring.datasource.password=123456#-----------------------------------# Jpa使用#-----------------------------------# 目标数据库进行操作，默认情况下自动检测。可以使用“databasePlatform”属性设置。#spring.jpa.database= demo1# 要操作的目标数据库的名称，默认情况下自动检测。 也可以使用“Database”枚举来设置。#spring.jpa.database-platform=DEMO# DDL模式 一般有这几种方式,Spring Boot会根据是否认为您的数据库是嵌入式的，为您选择一个默认值# update: 更新架构时，使用;spring.jpa.hibernate.ddl-auto=update# 是否启用SQL语句的日志记录spring.jpa.show-sql=true#----------------------------------------# TESTING PROPERTIES#----------------------------------------# 要替换的现有DataSource的类型spring.test.database.replace=any# MVC打印选项spring.test.mockmvc.print=default# ---------------大家查看文档进行配置，不一一列举了----------------------# 各个属性注解在查看常用配置文件application.properties中# FREEMARKER# DEVTOOLS配置# SPRING HATEOAS# HTTP message conversion# GSON# JDBC# JEST (Elasticsearch HTTP client) (JestProperties)# CASSANDRA (CassandraProperties)# --------------------------等等---------------------------------- 查看常用配置文件application.properties 自定义属性 由于有时为了方便项目的开发维护，我们可能需要到自定义配置属性，接下来我们也来搞一下自定义属性配置。 在application.properties自定义配置属性: 1.application.properties添加: 12345#--------------------------------# 自定义属性#--------------------------------com.eirunye.defproname=&quot;root&quot;com.eirunye.defpropass=&quot;123456&quot; 2.在DefPropertyController.class引用 1234567891011121314@RestControllerpublic class DefPropertyController &#123; @Value(&quot;$&#123;com.eirunye.defproname&#125;&quot;) private String defProName; @Value(&quot;$&#123;com.eirunye.defpropass&#125;&quot;) private String defProPass; @RequestMapping(value = &quot;/defproprety&quot;) public String defPropretyUser() &#123; return &quot;这个自定义属性名为: &quot; + defProName + &quot;, 密码为:&quot; + defProPass; &#125;&#125; 注意在获取自定义属性时一定要严格按照配置文件来获取并且Value里面的字符串一定是$+花括号{***},花括号里面的***表示为:application.properties里面自定义的字符串，所以本例就是表示为:@Value(&quot;${com.eirunye.defproname}&quot;) 。如果application.properties有自定义为test.ok=&quot;haha&quot;,同样的获取方式为:@Value(&quot;${test.ok}&quot;) 3.测试这里暂未使用测试代码的方式，后面的文章会讲到 IntelliJ IDEA访问1http://localhost:8084/defproprety Postman访问 通过Bean的形式获取 假如我们遇到这样情况，自定义属性多，然后每个都是通过@Value(${&quot;&quot;})方式的话可能会很容易出错，那么我们可以采用以下方式。 1.新建一个Properties.class添加@ConfigurationProperties(prefix = &quot;com.eirunye&quot;)//表示的是通过自定义属性查找，如果自定义是:test.ok=haha,则该这样表示:@ConfigurationProperties(prefix = &quot;test&quot;) 1234567891011121314151617@ConfigurationProperties(prefix = &quot;com.eirunye&quot;)//添加该注解public class Properties &#123; private String defproname; private String defpropass;// get/set方法 public String getDefproname() &#123; return defproname; &#125; public void setDefproname(String defproname) &#123; this.defproname = defproname; &#125; public String getDefpropass() &#123; return defpropass; &#125; public void setDefpropass(String defpropass) &#123; this.defpropass = defpropass; &#125;&#125; 2.在controller包下创建 DefBeanPropertyController.class 12345678910@RestControllerpublic class DefBeanPropertyController &#123; //通过 Autowired注解来获取到 Properties属性，注:Autowired是按类型进行装配，可获取它所装配类的属性 @Autowired Properties properties; @RequestMapping(value = &quot;/bean/defproperty&quot;) public String getDefBeanProperties() &#123; return &quot;这是通过Bean注解的方式获取属性: &quot; + properties.getDefproname() + &quot;,密码为: &quot; + properties.getDefpropass(); &#125;&#125; 3.在项目的入口文件Application添加注解@EnableConfigurationProperties最后加上包名不然可能找不到扫描文件如:@EnableConfigurationProperties({com.eirunye.defpropertys.bean.Properties.class})。 12345678@SpringBootApplication@EnableConfigurationProperties(&#123;com.eirunye.defpropertys.bean.Properties.class&#125;)//添加注解bean的扫描文件public class DefpropertysApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DefpropertysApplication.class, args); &#125;&#125; 4.测试IntelliJ IDEA访问 创建文件xxx.properties文件方式 我们可以自己创建一个自定义属性的文件如本例def.properties，(注:一般都是以 .properties 文件结尾) 1.添加自定义def.properties配置如下: 1234567#--------------------------------# 自定义属性#--------------------------------# 用户名com.eirunye.defineuser=&quot;property&quot;# 年龄com.eirunye.defineage=20 2.创建 DefineProperties.class 12345678910111213141516171819202122@Configuration@ConfigurationProperties(prefix = &quot;com.eirunye&quot;)//添加注解 ConfigurationProperties &quot;com.eirunye&quot;表示的是自定义属性@PropertySource(&quot;classpath:defines.properties&quot;)// 添加注解 PropertySource 该注解能根据路径扫描到我们的文件public class DefineProperties &#123;// 这里可以通过@Value(&quot;$&#123;&#125;&quot;)方式添加,我已经屏蔽掉了，直接通过ConfigurationProperties注解的方式// @Value(&quot;$&#123;com.eirunye.defineuser&#125;&quot;) private String defineuser;// @Value(&quot;$&#123;com.eirunye.defineage&#125;&quot;) private int defineage;// get/set方法 public String getDefineuser() &#123; return defineuser; &#125; public void setDefineuser(String defineuser) &#123; this.defineuser = defineuser; &#125; public int getDefineage() &#123; return defineage; &#125; public void setDefineage(int defineage) &#123; this.defineage = defineage; &#125;&#125; 3.在DefinePropertiesController.class引用 123456789@RestControllerpublic class DefinePropertiesController &#123; @Autowired DefineProperties defineProperties; @RequestMapping(value = &quot;define/Properties&quot;) public String getDefinePropertiesData()&#123; return &quot;新建文件自定义属性姓名：&quot;+defineProperties.getDefineuser()+&quot;,新建文件自定义属性年龄：&quot;+defineProperties.getDefineage(); &#125;&#125; 4.别忘了在Application里面添加配置@EnableConfigurationProperties,即：@EnableConfigurationProperties({com.eirunye.defpropertys.bean.Properties.class,com.eirunye.defpropertys.bean.DefineProperties.class}) 5.测试 1http://localhost:8084/define/Properties 下载application.properties案例demo application.yml配置由于application.properties配置有点繁琐，简洁是我们非常喜欢的，那么在Spring Boot程序里面当然也是可以用.yml文件来配置的，接下来让我们进入对.yml文件的一些相关配置吧，官方文档Using YAML Instead of Properties。 常见的配置首先在src目录下的/main/resource文件夹中新建application.yml、application-dev.yml、application-prod.yml三个文件，删除application.properties文件，目录结构如下:123456|--src |--main |--resources |--application.yml |--application-dev.yml |--application-prod.yml 相信很多人要骂街了，这什么情况不是说,yml配置很给力吗？怎么还有创建那么多文件，这不是比上面的 application.properties配置还多此一举吗？莫急接下来让我们来看看.yml的配置之后，我相信你肯定在项目中会喜欢用它。 常见的配置属性如下: 【注意: 这里属性之间的间隔必须按照要求而来,如:冒号后面要空格】application.yml 配置 123456789101112131415161718192021222324252627spring: profiles: active: dev #引用 application-dev.yml文件,这里我们可以改为 prod,表示引用application-prod.yml文件 datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/demo?useSSL=false&amp;requireSSL=false&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC username: root password: 12346 jpa: hibernate: ddl-auto: update show-sql: true data: mongodb: host: 127.0.0.1 uri: mongodb://localhost/test username: root password: 123456 database: test test: database: replace: any mockmvc: print: default servlet: multipart: enabled: true application-dev.yml 可以当成正式服务器端口 12server: port: 8084 application-prod.yml 可以当成测试服务器端口 12server: port: 8080 查看更多.yml配置 自定义yml配置 在application.yml配置 1.和上面的application.properties类似，但是需要注意的是格式问题1234com: eirunye: ymlname: ymlroot ymlpass: yml123456 2.通过@Value(&quot;${com.eirunye.ymlname}&quot;)获取 12345678910111213@RestControllerpublic class YmlPropertiesController&#123; @Value(&quot;$&#123;com.eirunye.ymlname&#125;&quot;) private String ymlname; @Value(&quot;$&#123;com.eirunye.ymlpass&#125;&quot;) private String ymlpass; @RequestMapping(value = &quot;yml/proprety&quot;) public String getYmlPropreties() &#123; return &quot;这个自定义属性名为: &quot; + ymlname+ &quot;, 密码为:&quot; + ymlpass; &#125;&#125; 3.测试—访问: 1http://localhost:8084/yml/proprety 通过Bean方式获取和application.properties方式一样 1.创建YmlPropertyBean.class 1234567@ConfigurationProperties(prefix = &quot;com.eirunye&quot;)//添加该注解public class YmlPropertyBean &#123; private String ymlname; private String ymlpass;// get/set方法.....&#125; 2.在 YmlPropertyBeanController.class引用 123456789@RestControllerpublic class YmlPropertyBeanController &#123; @Autowired YmlPropertyBean propertyBean; @RequestMapping(value = &quot;/bean/ymlproperty&quot;) public String getYmlPropertyData()&#123; return &quot;这个bean自定义属性名为: &quot; + propertyBean.getYmlname()+ &quot;, 密码为:&quot; + propertyBean.getYmlpass(); &#125;&#125; 3.测试-访问 1http://localhost:8084/bean/ymlproperty 下载.yml案例demo 总结 1.本篇主要讲得配置文件，到此就结束了，在开发中这是我们经常用到。 2.在本篇有些相关配置，本例的代码实例还没涉及到，接下来会继续结合相关的配置案例继续更新。 3.相信大家也有所掌握。]]></content>
      <categories>
        <category>后台</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目创建(二)]]></title>
    <url>%2F2018%2F08%2F14%2FSpring-Boot-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[如何创建Spring Boot 项目？接下来我们将学习如何创建第一个Spring Boot项目 hello Spring Boot! 呢？ 我们将以 IntelliJ IDEA 开发工具为例创建Spring Boot项目 如果还没下载过IntelliJ IDEA,那么打开下载即可。 IntelliJ IDEA 破解码，这个之前是可以用的，谢谢作者分享，不知道还能不能用。 一切准备完成后，开始使用开发之旅吧。 IDEA创建Spring Boot项目流程如图所示 File —–&gt; New ——&gt; Project… 选择 Spring Initializr Project Matedata 选择Web —–&gt; Web —–&gt; Spring Boot版本(默认即可) 选择项目保存的文件夹 创建完成 查看项目目录12345678910|--src:源代码文件 |--main |--java:项目的代码Java代码编写在这里 |--resources:一般是配置文件等 |--static:静态资源文件(js、css、img) |--template:模板(.html等) |--application.properties: 配置文件 |--test:主要是用于测试|--target:是项目打包生成的.jar文件在这里|--pom.xml:是添加依赖文件、版本号、打包设置为Jar或者War等 (如下图:pom.xml.png) 查看 pom.xml 编辑配置application.properties 文件 一般需要配置一些端口，数据库连接、编码方式等，如下图123456#设置端口server.port=8084#session失效时间server.session-timeout=3000#编码方式server.tomcat.uri-encoding=utf-8 程序的入口文件 编写简单的例子 如下图所示:12345创建一个controller 包，在包下创建 HelloController.class添加注解: @RestController ----&gt;默认Json格式数据 @GetMapping(value = &quot;/hello&quot;) &apos;hello&apos;:表示访问路径 解下来的文章会讲述到更多的注解...... 测试运行是否正常 如下图 访问测试:1浏览器访问 1IDEA 自带的访问(推荐) 1Postman 访问(推荐) 下载安装 Postman 本例项目下载demo 总结 在IDEA开发工具中构建Spring Boot非常简单，推荐大家使用IDEA(Eclipse创建项目在这里不举例了)。 接下来讲解的是Spring Boot 的相关配置。]]></content>
      <categories>
        <category>后台</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 认识(一)]]></title>
    <url>%2F2018%2F08%2F14%2FSpring-Boot-knowledge-1%2F</url>
    <content type="text"><![CDATA[SpringMVC 、Spring Boot 、SpringCloud 认识最近开发项目一直用到了Spring Boot脚手架工具，让我们来认识它一下吧，进入Spring Boot开发之旅。 认识Spring Boot Spring Boot 是由 Pivotal 团队提供的全新框架，其目的是用来简化新 Spring 应用的初始搭建以及开发过程。 Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. 在开发中给了我们很大的便利，不用进行过多的配置，和繁琐的设置，非常方便我们学习了开发项目。 总结一下几点非常棒: 1234入门简单开发效率高无须额外的配置监控运行过程等 Spring Boot 和Spring MVC区别 Spring MVC 123Spring MVC 是Spring的一个模块，是一种解决Web开发应用的框架。这种开发模式层次分明，轻度解耦，为Web应用提供了许多模板，减轻了开发难度，但是Spring都要进行复杂的XML、JavaConfig等资源的配置。Spring MVC 框架使用IOC对控制逻辑和业务提供了全面的分离，从而很好的解决了复杂错乱的问题。Spring MVC 需要过分的配置，导致花费更多的时间，效率低下。 Spring Boot 12345Spring Boot 创建完成后，提供了许多复杂的配置，降低了开发的进度和成本。例如: Spring Boot创建完成后，可以集成JDBC、Redis、MySQL、JackJson等等这些配置，让我们在开发过程中收益，只要关注业务，完成相关业务即可，从而不必担心配置的问题。Spring Boot 可以直接独立运行，简单即可。Spring Boot 是Spring的一套快速配置脚手架框架，Spring Boot 提供了一系列的相关配置，还有相关了Maven依赖，完全可靠，开发功能和Spring MVC相关功能兼容。Spring Boot 提供了基于http、ssh、telnet等对运行时的项目进行监控。Spring Boot 降低学习成本，快速入手开发项目，没有繁琐的配置(这是是广大开发者梦寐以求的) Spring Boot 和Spring Cloud区别Spring Cloud 1234Spring Cloud 是一种云端分布式架构的解决框架(称为微服务)。Spring Cloud 是一个基于 Spring Boot 框架实现云微服务应用开发的一套工具.Spring Cloud 主要是专注于服务之间的通讯、熔断、监控等全局的微服务治理框架。Spring Cloud 是不能离开Spring Boot这个环境的，Spring Cloud必须依赖于Spring Boot，但是Spring Boot可以离开Spring Cloud独立使用开发项目。 总结 各位读者如果有更好的见解可以留言，我们一起学习。 我们在不断的进步中，将会对Spring Boot系列进行深入的探究。]]></content>
      <categories>
        <category>后台</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>
